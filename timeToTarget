{"name":"timeToTarget","version":"1.3.1","type":"sensor","script":"waylay.analytics.baseUrl = options.globalSettings.waylay_analytics ||  'https://ts-analytics.waylay.io'\n\nvar resource = waylayUtil.getProperty(options, 'resource') || waylayUtil.getResource(options)\nvar metric =  waylayUtil.getProperty(options, 'metric')\n// backward compatibility with metric\nvar tsaConfig =  waylayUtil.getProperty(options, 'tsaConfig') || metric\n\n\nif (!resource || !tsaConfig)  {\n    send(new Error( 'no resource and tsaConfig specified' ))\n}\n\nvar params = waylayUtil.getProperty(options, 'params') || { }\nvar confidenceLevel = waylayUtil.getProperty(options, 'confidenceLevel') || 0.5\nif (confidenceLevel > 1) {\n    confidenceLevel = confidenceLevel / 100\n}\nvar trend = waylayUtil.getProperty(options, 'trend') || 'NOT_SET'\nvar target = parseFloat(waylayUtil.getProperty(options, 'target') || 0 )\n\nparams = prepareParams(params)\nwaylay.analytics.predict(resource, tsaConfig, params).then( sendResult , sendError )\n\n// ======= function definitions =========\n\nfunction prepareParams(parameters) {\n    parameters.predict = parameters.predict || { }\n    var window_spec = waylayUtil.getProperty(options, \"window\")\n    if ( typeof window_spec === 'string' && window_spec.indexOf('P') > -1 ) {\n        // iso period string like 'PT1H'\n        parameters.predict.window = window_spec\n    } else if (window_spec) {\n        // number of seconds\n        parameters.predict.window = 'PT' + parseInt(window_spec) + 'S'\n    } else {\n        // using default prediction window stored on the Analytics Option Configuration\n    }\n    // convert 1-sided confidence level to 2-sided alpha, as Arima currently only returns a two-sided confidence interval\n    var alpha =  1 - Math.abs(2 * confidenceLevel - 1)\n    alpha = Math.round(alpha * 1000) / 1000\n    parameters.predict.alpha = alpha\n    return parameters\n}\n \nfunction sendResult (res) {\n    \n  if ( !res.last_observation) {\n      send(new Error( 'no observation found' ))\n  }\n  \n  var data_key = res.options.metric\n  \n  if ( trend === 'NOT_SET' ) {\n      trend = (target < res.last_observation[data_key]) ? 'down' : 'up'\n  } \n\n  var predictionValueGetter = (pred) => { return parseFloat(pred[data_key]) }\n\n  if (res.predictions.length > 0) {\n    if ( res.predictions[0][data_key]['forecast'] ) {\n        // new format for reporting confidence levels\n        predictionValueGetter = (pred) => { return parseFloat(pred[data_key].forecast)  }\n        if ( confidenceLevel != 0.5 ) {\n            var ci_key =  (  (trend === 'down') === (confidenceLevel > 0.5) ) ? 'ci_upper' : 'ci_lower'\n            if (!res.predictions[0][data_key][ci_key]) {\n                send(new Error( `prediction misses an '${data_key}.${ci_key}' value. You can only use confidenceLevel different from 0.5 for algorithms with confidence intervals, such as (S)Arima. Current algorithm is '${res.options.algorithm.name}'.` ))\n                return\n            } else {\n                 predictionValueGetter = (pred) => { return parseFloat(pred[data_key][ci_key]) }\n            }\n            \n        }\n    } else if ( confidenceLevel != 0.5 ) {\n      // legacy format\n      data_key =  (  (trend === 'down') === (confidenceLevel > 0.5) ) ? data_key+'_ci_upper' : data_key+'_ci_lower'\n      if (!res.predictions[0][data_key]) {\n         send(new Error( `prediction misses an '${data_key}' value. You can only use confidenceLevel different from 0.5 for algorithms with confidence intervals, such as Arima. Current algorithm is '${res.options.algorithm.name}'.` ))\n         return\n      } else {\n         predictionValueGetter = (pred) => { return parseFloat(pred[data_key]) }\n      }\n    } \n  }\n  \n  const predictionFilter = (trend === 'up') ? \n     (pre) => { return predictionValueGetter(pre) > target } :\n     (pre) => { return predictionValueGetter(pre) < target } ;\n  \n  const extremalAggr = (trend === 'up') ? \n      (extr,pred) => { return Math.max(extr,predictionValueGetter(pred)) }: \n      (extr,pred) => { return Math.min(extr,predictionValueGetter(pred)) };\n    \n  var extremal = _.reduce( res.predictions,extremalAggr, res.last_observation[res.options.metric] )\n   \n  console.log(`veryfying whether predicted '${data_key}' will be ${ trend==='up'?'above':'below' } ${target} (confidence=${confidenceLevel}, 2-sided alpha=${params.predict.alpha})  `)\n  var filteredPredictions = _.filter(res.predictions, predictionFilter)\n  \n  var value = {\n    observedState: filteredPredictions.length > 0 ? 'Crossed' : 'Not Crossed',\n    rawData: {\n        target,\n        crossed_at: filteredPredictions.length > 0 ? filteredPredictions[0] : undefined,\n        confidence_level: confidenceLevel,\n        prediction_window: res.options.predict.window,\n        trend: trend,\n        extremal: extremal,\n        last_observation: res.last_observation,\n        first_prediction: res.predictions[0],\n        last_prediction: res.predictions[res.predictions.length-1],\n    }\n  }\n  send(null, value)\n}\n\nfunction sendError(err) {\n    if (err.response) {\n        console.error(err.response.data)\n        send( new Error( JSON.stringify({ \n            method:err.response.request.method, \n            path:err.response.request.path, \n            status:err.response.status, \n            message:err.response.data.error \n        } ) ) )\n    } else {\n        console.error(err)\n        send(err)\n    }\n}\n\n\n","metadata":{"author":"thomas","category":"TS Analytics","description":"prediction of boundary crossing\n\n<h5>Properties</h5>\n<ul>\n<li><code>resource</code></li>\n<li><code>tsaConfig</code> name of the  <a href='https://docs.waylay.io/features/tsanalytics/'>Time Series Analytics</a> configuration</li>\n<li><code>target</code> threshold value that is checked </li>\n<li><code>window</code> size of prediction window in seconds (default 3600). Alternatively you can use an <a href='https://en.wikipedia.org/wiki/ISO_8601#Durations'>iso8601 duration expression</a> such as 'PT2H' </li>\n<li><code>trend</code> 'up' if checking that predictions will be higher than target, 'down' if lower than target. \n<p>When not set, direction depends on the last observation ('up' if target > last_observation)</p></li>\n<li><code>confidenceLevel</code> \nconfidence level of the prediction: indicates the minimal proportion of the prediction distribution that must cross the target.</p>\n<p><code>confidenceLevel=0.5</code> (default) can be used with all algorithms, and checks whether the (most likely) prediction crosses the target.</p>\n<p>Other values for <code>confidenceLevel</code> check that target is crossed with that confidence (according to the confidence interval produced by the model!). </p>\n<p>Currently only Arima supports confidence intervals for predictions. </p>\n<p>By default (e.g. confidenceLevel=0.5)\n    <ul>\n    <li> <b>Crossed</b> means that, according to the model, there is above 50% chance that the target might be crossed; </li>\n    <li><b>Not Crossed</b> hence means that this chance is below 50% (or likewise an above 50% chance that target is NOT crossed). </li>\n    </ul>\n</p>\n<p>When low (e.g. confidenceLevel=0.1), \n   <ul>\n    <li> <b>Crossed</b> means that the target might be attained (at least 1 in 10);  </li>\n   <li> <b>Not Crossed</b> means that there is above 90% chance that the target will NOT be attained</li>\n    </ul>\n</p>\n<p>When high (e.g. confidenceLevel=0.9), \n   <ul>\n    <li> <b>Crossed</b> means that the target most probably will be attained (more than 9 out of 10, according to the model); </li>\n   <li> <b>Not Crossed</b> that there is above 10% chance that the target will NOT be attained</li>\n    </ul>\n</p> \n</li>\n<li><code>params</code> overrides for the analytics option configuration (see below)</li>\n</ul>\n<h5>States</h5>\n<ul>\n<li><b>Crossed</b> if it is predicted that values above (up) or below (down) the target will be attained ( with above <code>confidenceLevel</code> probability )</li>\n<li><b>Not Crossed</b> otherwise </li>\n</ul>\n<h5>Raw data returned</h5>\n<ul>\n<li><code>target</code> the target value</li>\n<li><code>crossed_at</code> observation at which the target is crossed first </li>\n<li><code>confidence_level</code> confidence level used to decide whether the target might be attained</li>\n<li><code>prediction_window</code>the size of the prediction window in which target crossings are checked</li>\n<li><code>trend</code> <em>up</em> or <em>down</em>, depending whether predictions above or below the target were checked</li>\n<li><code>extremal</code> maximal lower ('trend=up') or minimal upper ('trend=down') boundary of the (one-sided) confidence intervals of the predictions. \n<p>For c=0.5, this is the maximal ('trend=up') or minimal ('trend=down') prediction.</p>\n</li>\n<li><code>last_observation</code> last observation before the predictions</li>\n<li><code>first_prediction</code> first prediction</li>\n<li><code>last_prediction</code> last prediction</li>\n</ul>\n\n<strong>you must have TS Analytics package to run this sensor.</strong>\n\n<p>\nBefore using this sensor, configure the analytics options for \nthis metric using the  <a href='https://docs.waylay.io/features/tsanalytics/'>analytics dashboard</a>.\nAlternatively you should give a complete option configuration in the\n<code>params</code> section. \nSee <a href='https://github.com/waylayio/TS_Analytics/blob/master/doc/apidoc.md'>apidoc</a>\non how to specify options.\n</p>\n\n","iconURL":"https://static.waylay.io/plugs/icons/ttt.png","supportedStates":["Crossed","Not Crossed"],"requiredProperties":["resource","tsaConfig","target","window","trend","confidenceLevel","params"],"requiredRawData":[],"rawData":[{"parameter":"target","dataType":"double"},{"parameter":"crossed_at","dataType":"object"},{"parameter":"prediction_window","dataType":"string"},{"parameter":"trend","dataType":"string"},{"parameter":"extremal","dataType":"double"},{"parameter":"last_observation","dataType":"object"},{"parameter":"first_prediction","dataType":"object"},{"parameter":"last_prediction","dataType":"object"}]}}
