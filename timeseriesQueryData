{"name":"timeseriesQueryData","version":"1.1.4","type":"sensor","script":"function parseISOStringDataInput (input) {\n    const duration = moment.duration(input)\n    return moment().subtract(duration).unix() * 1000\n}\n\nfunction parseTimestamp (timestamp) {\n    if (!isNaN(timestamp))\n        return timestamp\n    if (timestamp && timestamp !== '' && isNaN(timestamp))\n        return parseISOStringDataInput(timestamp)\n}\n\nfunction parseBoolean (input) {\n    return input === 'true'\n}\n\nasync function execute () {\n    let {\n        queryName,\n        window,\n        from,\n        until,\n        removeTimestamp = false,\n        columnwise = false\n    } = options.requiredProperties\n    \n    columnwise = parseBoolean(columnwise)\n    removeTimestamp = parseBoolean(removeTimestamp)\n\n    if (!queryName || queryName === '')\n        return send(new Error('No valid queryName supplied'), { observedState : 'Not Collected' })\n    if (window && from && until)\n        return send(new Error(\"Only specify 2 out of the window, from and until properties.\"), { observedState : 'Not Collected' })\n    \n    const queryOptions = {}\n    if (window) queryOptions.window = window\n    if (from) queryOptions.from = from\n    if (until) queryOptions.until = until\n    queryOptions['render.mode'] = columnwise ? 'RENDER_MODE_SERIES' : 'RENDER_MODE_COMPACT_WS'\n    \n    const response = await waylay.analytics.getQueryData(queryName, queryOptions)\n        .catch(err => {\n            send(new Error(JSON.stringify({ \n                method:err.response.request.method, \n                path:err.response.request.path, \n                status:err.response.status, \n                message:err.response.data.error \n            })), { observedState : 'Not Collected' })\n        })\n\n    const hasData = response && response['data'] && response['data'][0]['columns'] && response['data'][0]['columns'].length > 1\n\n    if (hasData && removeTimestamp) {\n        response['data'][0]['columns'].shift()\n        \n        if (columnwise)\n            response['data'][0]['data'].shift()\n        else\n            response['data'][0]['data'] = response['data'][0]['data'].map(row => { row.shift(); return row; })\n    }\n    \n    if (columnwise) {\n        const nestedData = []\n        nestedData.push(response['data'][0]['data'])\n        response['data'][0]['data'] = nestedData\n    }\n    \n    send(null, {\n        observedState: hasData ? 'Collected' : 'Not Collected',\n        rawData: hasData ? response['data'][0] : response\n    })\n}\n\nexecute()","metadata":{"author":"Sander Vanhove","category":"Waylay","description":"Get the data as specified by a certain data query.\n\nYou can specify a `window`, `from` and `until` to control the time frame that is fetched.\nWhen doing so, keep in mind that you are able to specify only 2 out of these three,\nelse they will overwrite each other, resulting in unexpected behavior.\n\nThe `removeTimestamp` property will remove the timestamp from the data and columns when it's value is 'true'.\n\nThe `columnwise` property will make the data return columnwise when set to 'true'. By default the data will be returned rowwise.\n\n# Properties:\n- `queryName`: name of the query to execute.\n- `window`: the window of data to get, optional.\n- `from`: the timestamp from which to start getting data, optional.\n- `until`: the timestamp up until to get data, optional.\n- `removeTimestamps`: whether timestamps should be removed, optional.\n- `columnwise`: whether the data should be returned columnwise, optional.\n\n# States:\n- `Collected`: The results are collected and available.\n- `Not Collected`: Something went wrong and the results are not available.","iconURL":"https://static.waylay.io/icons/query_designer.png","supportedStates":["Collected","Not Collected"],"requiredProperties":["queryName","window","from","until","removeTimestamp","columnwise"],"requiredRawData":[],"rawData":[{"parameter":"data","dataType":"object[]"},{"parameter":"columns","dataType":"object[]"}]}}