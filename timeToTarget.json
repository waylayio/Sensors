{
  "name": "timeToTarget",
  "version": "1.3.7",
  "type": "sensor",
  "script": "async function execute () {\n  const resource = options.node.RESOURCE\n  const tsaConfig = options.requiredProperties.tsaConfig\n  if (!resource || !tsaConfig) return send(new Error('No resource and tsaConfig specified'))\n\n  let confidenceLevel = options.requiredProperties.confidenceLevel || 0.5\n  if (confidenceLevel > 1) confidenceLevel = confidenceLevel / 100\n  const trend = options.requiredProperties.trend || 'NOT_SET'\n  const target = parseFloat(options.requiredProperties.target) || 0\n  const window = options.requiredProperties.window\n\n  let params = options.requiredProperties.params || {}\n  params = prepareParams(params, window, confidenceLevel)\n\n  waylay.analytics.predict(resource, tsaConfig, params)\n    .then(response => sendResult(response, trend, target, confidenceLevel, params, send))\n    .catch(err => sendError(err, send))\n}\n\nfunction prepareParams (parameters, windowSpec, confidenceLevel) {\n  if (typeof parameters === 'string') {\n    parameters = JSON.parse(parameters)\n  }\n\n  parameters.predict = parameters.predict || {}\n  if (typeof windowSpec === 'string' && windowSpec.indexOf('P') > -1) {\n    // iso period string like 'PT1H'\n    parameters.predict.window = windowSpec\n    parameters.predict.periods = null\n  } else if (windowSpec) {\n    // number of seconds\n    parameters.predict.window = `PT${parseInt(windowSpec)}S`\n    parameters.predict.periods = null\n  }\n\n  // convert 1-sided confidence level to 2-sided alpha, as Arima currently only returns a\n  // two-sided confidence interval\n  const alpha = 1 - Math.abs(2 * confidenceLevel - 1)\n  // Round alpha to 3 decimal places\n  parameters.predict.alpha = Math.round(alpha * 1000) / 1000\n  return parameters\n}\n\nfunction getDataKey (res, confidenceLevel, trend) {\n  let dataKey = res.options.metric\n  if (!res.predictions[0][dataKey].forecast && confidenceLevel !== 0.5) { dataKey = (trend === 'down') === (confidenceLevel > 0.5) ? `${dataKey}_ci_upper` : `${dataKey}_ci_lower` }\n  return dataKey\n}\n\nfunction getPredictionExtractor (res, dataKey, trend, confidenceLevel, send) {\n  if (res.predictions.length === 0) { return pred => parseFloat(pred[dataKey]) }\n\n  if (res.predictions[0][dataKey] && res.predictions[0][dataKey].forecast) {\n    // new format for reporting confidence levels\n    if (confidenceLevel !== 0.5) {\n      const ciKey = (trend === 'down') === (confidenceLevel > 0.5) ? 'ci_upper' : 'ci_lower'\n      if (!res.predictions[0][dataKey][ciKey]) { return send(new Error(`'${res.options.algorithm.name}' does not support confidenceLevel. Prediction misses an '${dataKey}.${ciKey}' value. You can only use confidenceLevel different from 0.5 for algorithms with confidence intervals, such as (S)Arima.`)) }\n\n      return pred => parseFloat(pred[dataKey][ciKey])\n    }\n\n    return pred => parseFloat(pred[dataKey].forecast)\n  } else if (confidenceLevel !== 0.5) {\n    // legacy format\n    if (!res.predictions[0][dataKey]) { return send(new Error(`'${res.options.algorithm.name}' does not support confidenceLevel. Prediction misses an '${dataKey}' value. You can only use confidenceLevel different from 0.5 for algorithms with confidence intervals, such as Arima.`)) }\n\n    return pred => parseFloat(pred[dataKey])\n  }\n\n  return pred => parseFloat(pred[dataKey])\n}\n\nfunction sendResult (res, trend, target, confidenceLevel, params, send) {\n  if (!res.last_observation) return send(new Error('no observation found'))\n\n  const metric = res.options.metric\n  if (trend === 'NOT_SET') trend = target < res.last_observation[metric] ? 'down' : 'up'\n\n  const dataKey = getDataKey(res, confidenceLevel, trend)\n  const predictionValueGetter = getPredictionExtractor(res, dataKey, trend, confidenceLevel, send)\n  if (!predictionValueGetter) return\n\n  const predictionFilter = trend === 'up'\n    ? pre => predictionValueGetter(pre) > target\n    : pre => predictionValueGetter(pre) < target\n\n  const extremalAggr = trend === 'up'\n    ? (extr, pred) => Math.max(extr, predictionValueGetter(pred))\n    : (extr, pred) => Math.min(extr, predictionValueGetter(pred))\n\n  const extremal = res.predictions.reduce(extremalAggr, res.last_observation[metric])\n\n  console.log(`Verifying whether predicted '${dataKey}' will be ${trend === 'up' ? 'above' : 'below'} ${target} (confidence=${confidenceLevel}, 2-sided alpha=${params.predict.alpha})`)\n  const filteredPredictions = res.predictions.filter(predictionFilter)\n\n  const result = {\n    observedState: filteredPredictions.length > 0 ? 'Crossed' : 'Not Crossed',\n    rawData: {\n      target,\n      crossed_at: filteredPredictions.length > 0 ? filteredPredictions[0] : undefined,\n      confidence_level: confidenceLevel,\n      prediction_window: res.options.predict.window,\n      trend: trend,\n      extremal: extremal,\n      last_observation: res.last_observation,\n      first_prediction: res.predictions[0],\n      last_prediction: res.predictions[res.predictions.length - 1]\n    }\n  }\n\n  send(null, result)\n}\n\nfunction sendError (err, send) {\n  if (err.response) {\n    console.error(err.response.data)\n    return send(new Error(JSON.stringify({\n      method: err.response.request.method,\n      path: err.response.request.path,\n      status: err.response.status,\n      message: err.response.data.error\n    })))\n  }\n\n  console.error(err)\n  send(err)\n}\n\nexecute()",
  "metadata": {
    "author": "",
    "category": "",
    "description": "<h4>timeToTarget Sensor</h4>\n\nprediction of boundary crossing\n\n<h5>Properties</h5>\n<ul>\n<li><code>tsaConfig</code> name of the  <a href=\"https://docs.waylay.io/features/tsanalytics/\">Time Series Analytics</a> configuration</li>\n<li><code>target</code> threshold value that is checked </li>\n<li><code>window</code> size of prediction window in seconds (default 3600). Alternatively you can use an <a href='https://en.wikipedia.org/wiki/ISO_8601#Durations'>iso8601 duration expression</a> such as 'PT2H' </li>\n<li><code>trend</code> 'up' if checking that predictions will be higher than target, 'down' if lower than target. \n\nThe to work on should be specified on the node. Use '$' if this resource should be the task resource.\n\n<p>When not set, direction depends on the last observation ('up' if target > last_observation)</p></li>\n<li><code>confidenceLevel</code> \nconfidence level of the prediction: indicates the minimal proportion of the prediction distribution that must cross the target.</p>\n<p><code>confidenceLevel=0.5</code> (default) can be used with all algorithms, and checks whether the (most likely) prediction crosses the target.</p>\n<p>Other values for <code>confidenceLevel</code> check that target is crossed with that confidence (according to the confidence interval produced by the model!). </p>\n<p>Currently only Arima supports confidence intervals for predictions. </p>\n<p>By default (e.g. confidenceLevel=0.5)\n    <ul>\n    <li> <b>Crossed</b> means that, according to the model, there is above 50% chance that the target might be crossed; </li>\n    <li><b>Not Crossed</b> hence means that this chance is below 50% (or likewise an above 50% chance that target is NOT crossed). </li>\n    </ul>\n</p>\n<p>When low (e.g. confidenceLevel=0.1), \n   <ul>\n    <li> <b>Crossed</b> means that the target might be attained (at least 1 in 10);  </li>\n   <li> <b>Not Crossed</b> means that there is above 90% chance that the target will NOT be attained</li>\n    </ul>\n</p>\n<p>When high (e.g. confidenceLevel=0.9), \n   <ul>\n    <li> <b>Crossed</b> means that the target most probably will be attained (more than 9 out of 10, according to the model); </li>\n   <li> <b>Not Crossed</b> that there is above 10% chance that the target will NOT be attained</li>\n    </ul>\n</p> \n</li>\n<li><code>params</code> overrides for the analytics option configuration (see below)</li>\n</ul>\n<h5>States</h5>\n<ul>\n<li><b>Crossed</b> if it is predicted that values above (up) or below (down) the target will be attained ( with above <code>confidenceLevel</code> probability )</li>\n<li><b>Not Crossed</b> otherwise </li>\n</ul>\n<h5>Raw data returned</h5>\n<ul>\n<li><code>target</code> the target value</li>\n<li><code>crossed_at</code> observation at which the target is crossed first </li>\n<li><code>confidence_level</code> confidence level used to decide whether the target might be attained</li>\n<li><code>prediction_window</code>the size of the prediction window in which target crossings are checked</li>\n<li><code>trend</code> <em>up</em> or <em>down</em>, depending whether predictions above or below the target were checked</li>\n<li><code>extremal</code> maximal lower ('trend=up') or minimal upper ('trend=down') boundary of the (one-sided) confidence intervals of the predictions. \n<p>For c=0.5, this is the maximal ('trend=up') or minimal ('trend=down') prediction.</p>\n</li>\n<li><code>last_observation</code> last observation before the predictions</li>\n<li><code>first_prediction</code> first prediction</li>\n<li><code>last_prediction</code> last prediction</li>\n</ul>\n\n<strong>you must have TS Analytics package to run this sensor.</strong>\n\n<p>\nBefore using this sensor, configure the analytics options for \nthis metric using the  <a href=\"https://docs.waylay.io/features/tsanalytics/\">Analytics Model Designer</a>.\nAlternatively you should give a complete option configuration in the\n<code>params</code> section. \n</p>\n\n",
    "iconURL": "https://static.waylay.io/plugs/icons/ttt.png",
    "supportedStates": [
      "Crossed",
      "Not Crossed"
    ],
    "requiredProperties": [
      "tsaConfig",
      "target",
      "window",
      "trend",
      "confidenceLevel",
      "params"
    ],
    "requiredRawData": [],
    "rawData": [
      {
        "parameter": "target",
        "dataType": "double"
      },
      {
        "parameter": "crossed_at",
        "dataType": "object"
      },
      {
        "parameter": "prediction_window",
        "dataType": "string"
      },
      {
        "parameter": "trend",
        "dataType": "string"
      },
      {
        "parameter": "extremal",
        "dataType": "double"
      },
      {
        "parameter": "last_observation",
        "dataType": "object"
      },
      {
        "parameter": "first_prediction",
        "dataType": "object"
      },
      {
        "parameter": "last_prediction",
        "dataType": "object"
      },
      {
        "parameter": "confidence_level",
        "dataType": "double"
      }
    ]
  }
}